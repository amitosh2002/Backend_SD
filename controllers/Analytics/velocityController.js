// controllers/velocityController.js
import { octokit } from "../../services/githubServices.js";
import { generateVelocityReport, geminiEnabled } from "../../services/geminiService.js";
import { computeDoraMetrics } from "../../services/metricsService.js";

/**
 * GET /api/ai/velocity?owner=org&repo=repo&since=2025-11-01&until=2025-11-29
 * Returns numeric DORA metrics and a human-friendly report generated by Gemini.
 */
export const generateDeveloperVelocity = async (req, res) => {
  try {
    const { owner, repo, since, until } = req.query;
    if (!owner || !repo) return res.status(400).json({ success: false, message: "owner & repo required" });

    // timeframe parse
    const sinceDate = since ? new Date(since) : new Date(Date.now() - 30 * 24 * 3600 * 1000);
    const untilDate = until ? new Date(until) : new Date();

    // We already computed metrics via computeDoraMetrics
    const { numericMetrics, samplePRs, sampleIncidents } = await computeDoraMetrics({ octokit, owner, repo, since: sinceDate, until: untilDate });

    // Optional: include per-developer breakdown if requested
    const includeDeveloper = req.query.includeDeveloper === 'true' || req.query.includeDeveloper === '1';
    let developerMetrics = null;
    if (includeDeveloper) {
      const { computeDeveloperMetrics } = await import('../../services/metricsService.js');
      try {
        developerMetrics = await computeDeveloperMetrics({ octokit, owner, repo, since: sinceDate, until: untilDate });
      } catch (err) {
        console.warn('computeDeveloperMetrics failed', err.message || err);
        // don't fail the whole endpoint — include a warning field instead
        developerMetrics = { error: err.message || 'Failed to compute developer metrics' };
      }
    }

    // ---------- 6) Compose numeric results ----------
    function msToHuman(ms) {
      if (ms == null) return null;
      const s = Math.round(ms / 1000);
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      return `${hh}h ${mm}m ${ss}s`;
    }

    // numericMetrics, samplePRs and sampleIncidents returned from metrics service (used below to build prompt and response)

    // ---------- 8) Build a structured prompt for Gemini ----------
    const prompt = `
You are an engineering analytics assistant. Using the GitHub DORA metrics and sample data for ${owner}/${repo} between ${sinceDate.toISOString()} and ${untilDate.toISOString()}, generate a Developer Velocity Dashboard with the sections below (keep output concise but structured).

====================================================
1) SUMMARY
====================================================
Give 2–3 lines summarizing team speed + stability.

====================================================
2) METRIC SCORECARDS
====================================================
For DF, LTC, MTTR, CFR:
• numeric value  
• ↑ or ↓ indicator  
• 1-line interpretation  

====================================================
3) INSIGHTS
====================================================
For each metric, give: trend, risk, 1 improvement.

====================================================
4) GRAPH DESCRIPTIONS
====================================================
Short explanation for 4 charts:
- Deployment Frequency  
- Lead Time Trend  
- MTTR Trend  
- Change Failure Rate  

Each: best chart type + what the pattern means.

====================================================
5) TABLE SUMMARIES
====================================================
Use sample PRs & incidents to generate:
- PR table rows (6 max)
- Incident table rows (6 max)

====================================================
6) NEXT SPRINT (3 PRIORITIES)
====================================================

====================================================
7) TOP 3 RECOMMENDATIONS
====================================================

====================================================
8) FINAL JSON OUTPUT (DASHBOARD_JSON)
====================================================
Return **only this JSON**, nothing else after:

{
  "metrics": {
    "deploymentFrequency_per_day": number,
    "avgLeadTimeMs": number,
    "mttrMs": number,
    "changeFailureRatePercent": number
  },
  "velocityRadar": {
    "prVolume": number,
    "quality": number,
    "stability": number,
    "frequency": number,
    "efficiency": number
  },
  "graphs": {
    "deploymentFrequency": { "labels": [...], "values": [...] },
    "leadTime": { "labels": [...], "values": [...] },
    "mttr": { "labels": [...], "values": [...] },
    "changeFailureRate": { "labels": [...], "values": [...] }
  },
  "tables": {
    "pullRequests": [...samplePRs...],
    "incidents": [...sampleIncidents...]
  },
  "period": {
    "from": "${sinceDate.toISOString()}",
    "to": "${untilDate.toISOString()}"
  }
}

====================================================
DATA:
Numeric:
${JSON.stringify(numericMetrics, null, 2)}

PRs:
${JSON.stringify(samplePRs, null, 2)}

Incidents:
${JSON.stringify(sampleIncidents, null, 2)}


`;

    // ---------- 9) Call Gemini (if enabled) ----------
    let aiText = "[Gemini disabled - no AI report generated]";
    if (geminiEnabled) {
      aiText = await generateVelocityReport(prompt);
    }

    // ---------- 10) Return both numeric metrics + Gemini text ----------
    return res.json({
      success: true,
      metrics: numericMetrics,
      samplePRs,
      sampleIncidents,
      developerMetrics,
      aiReport: aiText
    });
  } catch (err) {
    console.error("generateDeveloperVelocity error:", err);
    return res.status(500).json({ success: false, error: err.message });
  }
};

export const generateDeveloperBreakdown = async (req, res) => {
  try {
    const { owner, repo, since, until } = req.query;
    if (!owner || !repo) return res.status(400).json({ success: false, message: "owner & repo required" });
    const sinceDate = since ? new Date(since) : new Date(Date.now() - 30 * 24 * 3600 * 1000);
    const untilDate = until ? new Date(until) : new Date();
    const { computeDeveloperMetrics } = await import('../../services/metricsService.js');
    const devMetrics = await computeDeveloperMetrics({ octokit, owner, repo, since: sinceDate, until: untilDate });
    return res.json({ success: true, repo: `${owner}/${repo}`, developerMetrics: devMetrics });
  } catch (err) {
    console.error('generateDeveloperBreakdown error:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
};

export const generateTeamVelocity = async (req, res) => {
  try {
    const { repos, since, until } = req.query; // repos=owner/repo,owner2/repo2
    if (!repos) return res.status(400).json({ success: false, message: 'repos query required (comma-separated list of owner/repo)' });
    const list = repos.split(',').map(r => r.trim()).filter(Boolean);
    if (list.length === 0) return res.status(400).json({ success: false, message: 'No repos provided' });
    const sinceDate = since ? new Date(since) : new Date(Date.now() - 30 * 24 * 3600 * 1000);
    const untilDate = until ? new Date(until) : new Date();
    // Build repo objects like { fullName: 'owner/repo' }
    const repoObjects = list.map(full => ({ fullName: full }));
    const { computeTeamMetrics } = await import('../../services/metricsService.js');
    const results = await computeTeamMetrics({ octokit, repos: repoObjects, since: sinceDate, until: untilDate });
    return res.json({ success: true, repos: list, analytics: results });
  } catch (err) {
    console.error('generateTeamVelocity error:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
};

export const compareRepoMetrics = async (req, res) => {
  try {
    const { owner, repo, sinceA, untilA, sinceB, untilB } = req.query;
    if (!owner || !repo || !sinceA || !untilA || !sinceB || !untilB) {
      return res.status(400).json({ success: false, message: 'owner, repo and both sinceA/untilA and sinceB/untilB are required' });
    }
    const { computeDoraMetrics, compareMetrics } = await import('../../services/metricsService.js');
    const a = await computeDoraMetrics({ octokit, owner, repo, since: new Date(sinceA), until: new Date(untilA) });
    const b = await computeDoraMetrics({ octokit, owner, repo, since: new Date(sinceB), until: new Date(untilB) });
    const delta = compareMetrics(a.numericMetrics, b.numericMetrics);
    return res.json({ success: true, repo: `${owner}/${repo}`, periodA: { sinceA, untilA }, periodB: { sinceB, untilB }, metricsA: a.numericMetrics, metricsB: b.numericMetrics, delta });
  } catch (err) {
    console.error('compareRepoMetrics error:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
};
