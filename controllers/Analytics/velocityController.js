// controllers/velocityController.js
import { octokit } from "../../services/githubServices.js";
import { generateVelocityReport, geminiEnabled } from "../../services/geminiService.js";

/**
 * GET /api/ai/velocity?owner=org&repo=repo&since=2025-11-01&until=2025-11-29
 * Returns numeric DORA metrics and a human-friendly report generated by Gemini.
 */
export const generateDeveloperVelocity = async (req, res) => {
  try {
    const { owner, repo, since, until } = req.query;
    if (!owner || !repo) return res.status(400).json({ success: false, message: "owner & repo required" });

    // timeframe parse
    const sinceDate = since ? new Date(since) : new Date(Date.now() - 30 * 24 * 3600 * 1000);
    const untilDate = until ? new Date(until) : new Date();

    // ---------- 1) Deployment Frequency (DF) ----------
    // list deployments and filter by environment=production and timeframe
    const deploymentsResp = await octokit.rest.repos.listDeployments({ owner, repo, per_page: 200 });
    const deployments = (deploymentsResp.data || []).filter(d => {
      const created = new Date(d.created_at || d.created || d.updated_at || Date.now());
      // optional: restrict to production environment
      const env = (d.environment || "").toLowerCase();
      return created >= sinceDate && created <= untilDate && (env === "production" || env === "prod" || !env);
    });

    const timeWindowDays = (untilDate - sinceDate) / (1000 * 3600 * 24) || 1;
    const deploymentFrequency = deployments.length / timeWindowDays; // deploys per day

    // ---------- 2) Lead Time for Changes (LTC) ----------
    // For each deployment, compute (deployCompletedTime - firstCommitTime)
    const leadTimes = [];
    for (const dep of deployments) {
      try {
        const sha = dep.sha;
        if (!sha) continue;
        // commit time
        const commitResp = await octokit.rest.repos.getCommit({ owner, repo, ref: sha });
        const commitTime = new Date(commitResp.data.commit.author.date);

        // deployment status to find when completed; fallback to dep.created_at
        const statusesResp = await octokit.rest.repos.listDeploymentStatuses({
          owner,
          repo,
          deployment_id: dep.id,
          per_page: 10
        });
        const status = statusesResp.data[0];
        const completedAt = status ? new Date(status.created_at || status.updated_at || dep.updated_at || dep.created_at) : new Date(dep.created_at);

        const ms = completedAt - commitTime;
        if (ms >= 0) leadTimes.push(ms);
      } catch (err) {
        // ignore per-deployment errors
        console.warn("LT calc error for dep", dep.id, err.message);
      }
    }
    const avgLeadTimeMs = leadTimes.length ? Math.round(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length) : null;

    // ---------- 3) Change Failure Rate (CFR) ----------
    // Count failed workflow runs / deployments associated with branch/sha
    // We'll examine workflow runs in timeframe and count failures
    const workflowRunsResp = await octokit.rest.actions.listWorkflowRunsForRepo({
      owner,
      repo,
      per_page: 200,
      status: "completed"
    });
    const workflowRuns = (workflowRunsResp.data.workflow_runs || []).filter(w => {
      const runAt = new Date(w.created_at);
      return runAt >= sinceDate && runAt <= untilDate;
    });

    const totalDeployOrRuns = Math.max(deployments.length, workflowRuns.length);
    const failedRuns = workflowRuns.filter(w => w.conclusion === "failure" || w.conclusion === "cancelled").length;
    const changeFailureRate = totalDeployOrRuns ? (failedRuns / totalDeployOrRuns) * 100 : 0;

    // ---------- 4) Mean Time To Recovery (MTTR) ----------
    // Use GitHub issues with label 'incident' within timeframe
    const incidentIssuesResp = await octokit.rest.issues.listForRepo({
      owner,
      repo,
      per_page: 200,
      since: sinceDate.toISOString()
    });
    const incidents = (incidentIssuesResp.data || []).filter(i => {
      const created = new Date(i.created_at);
      return created >= sinceDate && created <= untilDate && (i.labels || []).some(l => (typeof l === "string" ? l : l.name).toLowerCase().includes("incident"));
    });

    const mttrList = [];
    for (const inc of incidents) {
      if (!inc.closed_at) continue;
      const started = new Date(inc.created_at);
      const resolved = new Date(inc.closed_at);
      const ms = resolved - started;
      if (ms >= 0) mttrList.push(ms);
    }
    const avgMttrMs = mttrList.length ? Math.round(mttrList.reduce((a, b) => a + b, 0) / mttrList.length) : null;

    // ---------- 5) Supporting context: PRs, PR sizes, code churn (basic) ----------
    // get merged PRs in timeframe
    const prsResp = await octokit.rest.pulls.list({
      owner,
      repo,
      state: "closed",
      per_page: 200
    });
    const mergedPRs = (prsResp.data || []).filter(pr => pr.merged_at && new Date(pr.merged_at) >= sinceDate && new Date(pr.merged_at) <= untilDate);

    // compute avg PR size and churn (basic: additions+deletions)
    const prSizes = mergedPRs.map(p => (p.additions || 0) + (p.deletions || 0));
    const avgPrSize = prSizes.length ? Math.round(prSizes.reduce((a, b) => a + b, 0) / prSizes.length) : 0;

    // code churn estimate: for each PR fetch commits and compute deletions/additions from commit stats (costly)
    // For speed, we use PR additions/deletions as proxy for churn for now
    const codeChurnPercent = avgPrSize > 0 ? Math.round(((mergedPRs.reduce((acc, p) => acc + (p.deletions || 0), 0)) / avgPrSize) * 100) : 0;

    // ---------- 6) Compose numeric results ----------
    function msToHuman(ms) {
      if (ms == null) return null;
      const s = Math.round(ms / 1000);
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      return `${hh}h ${mm}m ${ss}s`;
    }

    const numericMetrics = {
      deploymentFrequency_per_day: Number(deploymentFrequency.toFixed(2)),
      deployments_count: deployments.length,
      avgLeadTimeMs,
      avgLeadTimeHuman: msToHuman(avgLeadTimeMs),
      changeFailureRatePercent: Number(changeFailureRate.toFixed(2)),
      mttrMs: avgMttrMs,
      mttrHuman: msToHuman(avgMttrMs),
      mergedPRCount: mergedPRs.length,
      avgPRSizeLines: avgPrSize,
      codeChurnPercent: codeChurnPercent
    };

    // ---------- 7) Pick sample items to feed to Gemini for context ----------
    const samplePRs = mergedPRs.slice(0, 6).map(p => ({
      number: p.number,
      title: p.title,
      merged_at: p.merged_at,
      additions: p.additions,
      deletions: p.deletions,
      url: p.html_url,
      author: p.user?.login
    }));

    const sampleIncidents = incidents.slice(0, 6).map(i => ({
      key: i.number,
      title: i.title,
      created_at: i.created_at,
      closed_at: i.closed_at,
      url: i.html_url
    }));

    // ---------- 8) Build a structured prompt for Gemini ----------
    const prompt = `
You are an engineering manager assistant. Given the following numeric DORA metrics and supporting context from the GitHub repository ${owner}/${repo} for the period ${sinceDate.toISOString()} to ${untilDate.toISOString()}, produce:

1) A short executive summary (2-4 lines).
2) A clear assessment of each DORA metric (Deployment Frequency, Lead Time for Changes, Mean Time to Recovery, Change Failure Rate) â€” include the numeric value and what it signals.
3) Top 3 actionable recommendations to improve developer velocity and reliability (no generic items; give concrete suggestions like "reduce PR size to < 200 LOC", "increase test coverage for service X", "add pre-merge checks for flakiness").
4) A prioritized checklist for next sprint (3 items).
5) A JSON object "insights" containing the four metrics and supportive fields (use machine-readable values).

Numeric metrics:
${JSON.stringify(numericMetrics, null, 2)}

Sample merged PRs:
${JSON.stringify(samplePRs, null, 2)}

Sample incidents:
${JSON.stringify(sampleIncidents, null, 2)}

Return the result as plain text with a final JSON block labeled "METRICS_JSON" containing the "insights" object only.
`;

    // ---------- 9) Call Gemini (if enabled) ----------
    let aiText = "[Gemini disabled - no AI report generated]";
    if (geminiEnabled) {
      aiText = await generateVelocityReport(prompt);
    }

    // ---------- 10) Return both numeric metrics + Gemini text ----------
    return res.json({
      success: true,
      metrics: numericMetrics,
      samplePRs,
      sampleIncidents,
      aiReport: aiText
    });
  } catch (err) {
    console.error("generateDeveloperVelocity error:", err);
    return res.status(500).json({ success: false, error: err.message });
  }
};
